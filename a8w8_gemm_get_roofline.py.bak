import itertools
import pandas as pd

MI350X_BW_MEM = 8e12  # TB/s
MI350X_BW_MEM_EMPIRICAL = 6e12  # TB/s
MI350X_PERF_FP8 = 4.6e15  # TFLOPS
MI350X_PERF_FP8_EMPIRICAL = 3.8e15  # TFLOPS
KERNEL_LAUNCH_OVERHEAD = 4e-6  # 3.5-4us


def calc_arithmetic_intensity(m, n, k, dtype="fp16"):
    if dtype == "fp16":
        factor = 2
    elif dtype == "fp8":
        factor = 1
    else:
        raise ValueError("Unsupported dtype. Use 'fp16' or 'fp8'.")

    return (2 * m * n * k) / (factor * (m * n + n * k + m * k))


def calc_roofline_time(m, n, k, bound, in_us=False):
    if bound == "compute":
        roofline_time = (2 * m * n * k) / MI350X_PERF_FP8_EMPIRICAL  # in seconds
        roofline_time = max(roofline_time, KERNEL_LAUNCH_OVERHEAD)
    else:
        bytes_moved = m * n + n * k + m * k  # in bytes
        roofline_time = bytes_moved / MI350X_BW_MEM_EMPIRICAL  # in seconds
        roofline_time = max(roofline_time, KERNEL_LAUNCH_OVERHEAD)

    if in_us:
        return roofline_time / 1e-6  # in us

    return roofline_time  # in seconds


def calc_roofline_throughput(m, n, k, bound, roofline_time_s=None):
    if roofline_time_s is None:
        roofline_time_s = calc_roofline_time(m, n, k, bound)
    flops = 2 * m * n * k  # in FLOPS
    return flops / roofline_time_s * 1e-12  # in TFLOPS


def calc_roofline_bandwidth(m, n, k, bound, roofline_time_s=None):
    if roofline_time_s is None:
        roofline_time_s = calc_roofline_time(m, n, k, bound)

    mem_read = m * k + n * k  # in bytes
    mem_write = (m * n) * 2  # in bytes
    mem = mem_read + mem_write  # in bytes
    return mem / roofline_time_s * 1e-9  # in GB/s


def main():
    # m_vals = [16, 32, 64, 128, 256, 512, 2000]
    # n_vals = [2048, 5120]
    # k_vals = [2048, 4096]
    m_vals = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384]
    # n_vals = [18432*2]
    n_vals = [2112]
    k_vals = [7168]

    combinations = list(itertools.product(m_vals, n_vals, k_vals))
    y_vals_fp8 = [calc_arithmetic_intensity(m, n, k, "fp8") for m, n, k in combinations]
    ops_byte_ratio_fp8 = MI350X_PERF_FP8 / MI350X_BW_MEM
    bounds_fp8 = ["memory" if y < ops_byte_ratio_fp8 else "compute" for y in y_vals_fp8]
    roofline_us_fp8 = [
        calc_roofline_time(m, n, k, b, in_us=True)
        for (m, n, k), b in zip(combinations, bounds_fp8)
    ]
    roofline_tflops_fp8 = [
        calc_roofline_throughput(m, n, k, b)
        for (m, n, k), b in zip(combinations, bounds_fp8)
    ]
    roofline_bw_fp8 = [
        calc_roofline_bandwidth(m, n, k, b)
        for (m, n, k), b in zip(combinations, bounds_fp8)
    ]
    df = pd.DataFrame(
        {
            "M": m,
            "N": n,
            "K": k,
            "AI FP8": y_val_fp8,
            "Bound FP8": bound_fp8,
            "RL time (us)": rl_us_fp8,
            "RL TFLOPS": rl_tflops_fp8,
            "RL BW (GB/s)": rl_bw_fp8,
        }
        for (m, n, k), y_val_fp8, bound_fp8, rl_us_fp8, rl_tflops_fp8, rl_bw_fp8 in zip(
            itertools.product(m_vals, n_vals, k_vals),
            y_vals_fp8,
            bounds_fp8,
            roofline_us_fp8,
            roofline_tflops_fp8,
            roofline_bw_fp8,
        )
    )
    df.to_csv("mnk_theoretical_peaked.csv", index=False)
    print("Ops/Byte Ratio FP8:", ops_byte_ratio_fp8)
    print(df)


if __name__ == "__main__":
    main()
